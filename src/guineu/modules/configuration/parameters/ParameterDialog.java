/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * ParameterDialog.java
 *
 * Created on Jun 23, 2010, 12:23:43 PM
 */
package guineu.modules.configuration.parameters;

import guineu.data.Dataset;
import guineu.util.components.HelpButton;
import guineu.util.dialogs.ExitCode;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.StringTokenizer;
import java.util.Vector;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;

/**
 *
 * @author scsandra
 */
public class ParameterDialog extends JDialog implements ActionListener {

    private JButton btnAddParameter, btnDeleteParameter, btnOK, btnCancel, btnHelp;
    private JTextField tField;
    private ExitCode exitCode = ExitCode.UNKNOWN;
    private ParameterDataModel model;
    private Clipboard system;
    private StringSelection stsel;
    private String rowstring, value;
    private Vector<register> registers;
    private Dataset dataset;
    int indexRegister = 0;

    /** Creates new form ParameterDialog */
    public ParameterDialog(String title, String helpID, Dataset dataset) {
        registers = new Vector<register>();
        this.dataset = dataset;

        initComponents();

        setTableProperties();

        if (dataset != null) {
            model = new ParameterDataModel(dataset, table);
            this.table.setModel(model);
        }
        tField = new JTextField("");
        tField.setPreferredSize(new Dimension(100, 25));
        btnAddParameter = new JButton("Add Parameter");
        btnAddParameter.addActionListener(this);
        btnDeleteParameter = new JButton("Delete Parameter");
        btnDeleteParameter.addActionListener(this);
        btnOK = new JButton("Save");
        btnOK.addActionListener(this);
        btnCancel = new JButton("Cancel");
        btnCancel.addActionListener(this);
        btnHelp = new HelpButton(helpID);
        btnPanel.add(tField);
        btnPanel.add(btnAddParameter);
        btnPanel.add(btnDeleteParameter);
        btnPanel.add(btnOK);
        btnPanel.add(btnCancel);
        btnPanel.add(btnHelp);

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        table = new javax.swing.JTable();
        btnPanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);

        table.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(table);

        getContentPane().add(jScrollPane1, java.awt.BorderLayout.PAGE_START);

        btnPanel.setPreferredSize(new java.awt.Dimension(699, 50));
        getContentPane().add(btnPanel, java.awt.BorderLayout.PAGE_END);

        pack();
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel btnPanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable table;
    // End of variables declaration//GEN-END:variables

    public void actionPerformed(ActionEvent e) {

        Object src = e.getSource();

        if (src == btnOK) {
            exitCode = ExitCode.OK;
            model.addParameters(dataset);
            dispose();
        }

        if (src == btnCancel) {
            exitCode = ExitCode.CANCEL;
            dispose();
        }

        if (src == btnAddParameter) {
            model.addColumn(tField.getText());
            table.createDefaultColumnsFromModel();
        }

        if (src == btnDeleteParameter) {
            model.addParameters(dataset);
            dataset.deleteParameter(table.getColumnName(table.getSelectedColumn()));
            model = new ParameterDataModel(dataset, table);
            table.setModel(model);
            table.validate();
        }



        //table behavior
        if (e.getActionCommand().compareTo("Copy") == 0) {
            StringBuffer sbf = new StringBuffer();
            // Check to ensure we have selected only a contiguous block of
            // cells
            int numcols = table.getSelectedColumnCount();
            int numrows = table.getSelectedRowCount();
            int[] rowsselected = table.getSelectedRows();
            int[] colsselected = table.getSelectedColumns();
            if (!((numrows - 1 == rowsselected[rowsselected.length - 1] - rowsselected[0] &&
                    numrows == rowsselected.length) &&
                    (numcols - 1 == colsselected[colsselected.length - 1] - colsselected[0] &&
                    numcols == colsselected.length))) {
                JOptionPane.showMessageDialog(null, "Invalid Copy Selection",
                        "Invalid Copy Selection",
                        JOptionPane.ERROR_MESSAGE);
                return;
            }
            for (int i = 0; i < numrows; i++) {
                for (int j = 0; j < numcols; j++) {
                    sbf.append(table.getValueAt(rowsselected[i], colsselected[j]));
                    if (j < numcols - 1) {
                        sbf.append("\t");
                    }
                }
                sbf.append("\n");
            }
            stsel = new StringSelection(sbf.toString());
            system = Toolkit.getDefaultToolkit().getSystemClipboard();
            system.setContents(stsel, stsel);
            table.validate();
        }
        if (e.getActionCommand().compareTo("Paste") == 0) {

            int startRow = (table.getSelectedRows())[0];
            int startCol = (table.getSelectedColumns())[0];
            register newRegister = null;
            String rtrstring;
            try {
                rtrstring = (String) (system.getContents(this).getTransferData(DataFlavor.stringFlavor));
                StringTokenizer rst1 = new StringTokenizer(rtrstring, "\n");
                rowstring = rst1.nextToken();
                StringTokenizer st2 = new StringTokenizer(rowstring, "\t");
                newRegister = new register(startRow, rst1.countTokens() + 1, startCol, st2.countTokens());
                newRegister.getValues();
            } catch (Exception ex) {
            }

            try {
                String trstring = (String) (system.getContents(this).getTransferData(DataFlavor.stringFlavor));
                StringTokenizer st1 = new StringTokenizer(trstring, "\n");
                for (int i = 0; st1.hasMoreTokens(); i++) {
                    rowstring = st1.nextToken();
                    StringTokenizer st2 = new StringTokenizer(rowstring, "\t");
                    for (int j = 0; st2.hasMoreTokens(); j++) {
                        value = st2.nextToken();
                        if (startRow + i < table.getRowCount() &&
                                startCol + j < table.getColumnCount()) {
                            table.setValueAt(value, startRow + i, startCol + j);
                        }
                    }
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }

            newRegister.getNewValues();
            this.registers.addElement(newRegister);
            this.indexRegister = this.registers.size() - 1;
            table.validate();
        }

        if (e.getActionCommand().compareTo("Delete") == 0) {
            register newRegister = new register(table.getSelectedColumns(), table.getSelectedRows());
            newRegister.getValues();

            int[] selectedRow = table.getSelectedRows();
            int[] selectedCol = table.getSelectedColumns();

            try {
                for (int i = 0; i < selectedRow.length; i++) {
                    for (int j = 0; j < selectedCol.length; j++) {
                        table.setValueAt("", selectedRow[i], selectedCol[j]);
                    }
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }

            newRegister.getNewValues();
            this.registers.addElement(newRegister);
            this.indexRegister = this.registers.size() - 1;
            table.validate();
        }

        if (e.getActionCommand().compareTo("Back") == 0) {
            this.registers.elementAt(indexRegister).back();
            if (indexRegister > 0) {
                indexRegister--;
            }
            table.validate();
        }

        if (e.getActionCommand().compareTo("Forward") == 0) {
            this.registers.elementAt(indexRegister).forward();
            if (indexRegister < this.registers.size() - 1) {
                indexRegister++;
            }
            table.validate();
        }
        System.gc();
    }

    /**
     * Method for reading exit code
     */
    public ExitCode getExitCode() {
        return exitCode;
    }


    public void setTableProperties() {

        table.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        table.setColumnSelectionAllowed(true);


        table.setAutoCreateRowSorter(true);
        table.setUpdateSelectionOnSort(true);

        KeyStroke copy = KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK, false);
        KeyStroke paste = KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK, false);
        KeyStroke delete = KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0, false);
        KeyStroke registerBack = KeyStroke.getKeyStroke(KeyEvent.VK_Z, ActionEvent.CTRL_MASK, false);
        KeyStroke registerForward = KeyStroke.getKeyStroke(KeyEvent.VK_Y, ActionEvent.CTRL_MASK, false);

        table.registerKeyboardAction(this, "Copy", copy, JComponent.WHEN_FOCUSED);
        table.registerKeyboardAction(this, "Paste", paste, JComponent.WHEN_FOCUSED);
        table.registerKeyboardAction(this, "Delete", delete, JComponent.WHEN_FOCUSED);
        table.registerKeyboardAction(this, "Back", registerBack, JComponent.WHEN_FOCUSED);
        table.registerKeyboardAction(this, "Forward", registerForward, JComponent.WHEN_FOCUSED);
        system = Toolkit.getDefaultToolkit().getSystemClipboard();
       
    }

    class register {

        int[] columnIndex;
        int[] rowIndex;
        Object[] values;
        Object[] newValues;

        public register(int[] columnIndex, int[] rowIndex) {
            this.columnIndex = columnIndex;
            this.rowIndex = rowIndex;
            values = new Object[columnIndex.length * rowIndex.length];
            newValues = new Object[columnIndex.length * rowIndex.length];
        }

        private register(int startRow, int rowCount, int startCol, int columnCount) {
            rowIndex = new int[rowCount];
            columnIndex = new int[columnCount];
            for (int i = 0; i < rowCount; i++) {
                rowIndex[i] = startRow + i;
            }
            for (int i = 0; i < columnCount; i++) {
                columnIndex[i] = startCol + i;
            }
            values = new Object[columnIndex.length * rowIndex.length];
            newValues = new Object[columnIndex.length * rowIndex.length];
        }

        public void getValues() {
            int cont = 0;
            for (int row : rowIndex) {
                for (int column : columnIndex) {
                    try {
                        values[cont++] = table.getValueAt(row, column);
                    } catch (Exception e) {
                    }
                }
            }
        }

        public void getNewValues() {
            int cont = 0;
            for (int row : rowIndex) {
                for (int column : columnIndex) {
                    try {
                        newValues[cont++] = table.getValueAt(row, column);
                    } catch (Exception e) {
                    }
                }
            }
        }

        public void back() {
            int cont = 0;
            for (int row : rowIndex) {
                for (int column : columnIndex) {
                    table.setValueAt(values[cont++], row, column);
                }
            }
        }

        public void forward() {
            int cont = 0;
            for (int row : rowIndex) {
                for (int column : columnIndex) {
                    table.setValueAt(newValues[cont++], row, column);
                }
            }
        }
    }
}
